family = 'gaussian',
constraints = '(x3 + `I(x3^2)`) > .01, x4 < .2',
optimizer = 'mcmc',
LOWER = -1,
ini.pars.coef = c(-.4, .12, -.004, 0.1, 0.1, .15))
fit2$coefficients
coef(fit2)
rbind(coef(fit1), coef(fit2))
summary(lm(y~x1+x2+x3+I(x3^2) + x4, data = fake_data))
rbind(fit1$metrics,
fit2$metrics)
fit2 = ConsReg(formula = y~x1+x2+x3+ I(x3^2) + x4, data = fake_data,
family = 'gaussian',
constraints = '(x3 + `I(x3^2)`) > .01, x4 < .2',
optimizer = 'mcmc',
LOWER = -1, UPPER = 1,
ini.pars.coef = c(-.4, .12, -.004, 0.1, 0.1, .15))
pred = predict(fit1, newdata = data[2:3,])
pred
fit2 = predict(fit2, newdata = data[2:3,])
pred
pred = cbind(fit1 = predict(fit1, newdata = data[2:3,]),
fit2 = predict(fit2, newdata = data[2:3,]))
pred = data.frame(fit1 = predict(fit1, newdata = data[2:3,]),
fit2 = predict(fit2, newdata = data[2:3,]))
fit1 = predict(fit1, newdata = data[2:3,])
fit2 = ConsReg(formula = y~x1+x2+x3+ I(x3^2) + x4, data = fake_data,
family = 'gaussian',
constraints = '(x3 + `I(x3^2)`) > .01, x4 < .2',
optimizer = 'mcmc',
LOWER = -1, UPPER = 1,
ini.pars.coef = c(-.4, .12, -.004, 0.1, 0.1, .15))
fit1 = ConsReg(formula = y~x1+x2+x3+ I(x3^2) + x4, family = 'gaussian',
optimizer = 'solnp',
data = fake_data)
pred = data.frame(fit1 = predict(fit1, newdata = data[2:3,]),
fit2 = predict(fit2, newdata = data[2:3,]))
pred
pred = data.frame(fit1 = predict(fit1, newdata = data[2:3,]),
fit2 = predict(fit2, newdata = data[2:3,]),
Real = data$y[2:3])
pred
pr = predict(fit2, components = T)
pr
pr = predict(fit2, components = T, newdata = data[5,])
pr
data('series')
series
plot(series$y, t='l')
head(series)
fit_ts1 = ConsRegArima(y ~ -1, order = c(1, 1), data = series)
fit_ts1$coefficients
arima(series$y, order = c(1, 0, 1))
arima(series$y, order = c(1, 0, 1), include.mean = F)
arima(series$y, order = c(1, 0, 1), include.mean = F, method = 'CSS')
fit_ts1$coefficients
coef(arima(series$y, order = c(1, 0, 1), include.mean = T, method = 'CSS'))
fit_ts1 = ConsRegArima(y ~ 1, order = c(1, 1), data = series)
fit_ts2 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series)
coef(arima(series$y, order = c(1, 0, 1), include.mean = F, xreg = series[,-1],  method = 'CSS'))
fit_ts2$coefficients
coef(arima(series$y, order = c(1, 0, 1), include.mean = T, xreg = series[,-1],  method = 'CSS'))
fit_ts2$coefficients
fit_ts2 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series)
ConsRegArima
ConsRegArima.formula
mod = arima(series$y, order = c(1, 0, 1), include.mean = T, xreg = series[,-1],  method = 'CSS')
accuracy(mod)
fit_ts2$metrics
accuracy(mod$x[-c(1:3)], fitted(mod)[-c(1:3)])
accuracy(mod$x[-c(1:3)], fitted(mod)[-c(1:3)])
mod$x
mod$y
mod$series
accuracy(series$y[-c(1:3)], fitted(mod)[-c(1:3)])
accuracy(series$y[-c(1:3)], fit_ts2$fitted[-c(1:3)])
fit_ts2$coefficients
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2")
fit_ts3$coefficients
)
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3, .7, -.2)
)
fit_ts3$coefficients
constraints = "x4 < x2"
LOWER = -1
UPPER = 1
formula = y ~ x1+x2+x3+x4
data = series
na.action = 'na.omit'
objective_function = 'arma_fun2'
penalty = 1000
optimizer = c('solnp')
order = c(1,1)
optimizer = switch(optimizer,
'solnp' = 'solnp.opt',
'gosolnp' = 'gosolnp.opt',
'optim' = 'optim.opt',
'nloptr' = 'nloptr.opt',
'DEoptim' = 'DEoptim.opt',
'dfoptim' = 'hjkb.opt',
'mcmc' = 'mcmc.opt',
'MCMCmetrop' = 'MCMCmetrop.opt')
if (missing(data))
data <- environment(formula)
mf <- model.frame(formula=formula, data=data, na.action = na.action)
x <- model.matrix(attr(mf, "terms"), data=mf)
y <- model.response(mf)
constraints
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2"
)
fit_ts3$coefficients
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3)
)
fit_ts3$coefficients
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3)
)
fit_ts3$coefficients
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3)
)
fit_ts3
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3, .234)
)
fit_ts3$coefficients
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series,
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3)
)
fit_ts3$coefficients
pred = predict(fit_ts3, newdata = series[61:63], h=3)
pred = predict(fit_ts3, newdata = series[61:63, ], h=3)
pred
cbind(pred, series$y[61:63])
pred
pred = predict(fit_ts3, newdata = series[61:63, ], h=3, intervals = 90)
pred
plot(pred)
plot(pred) + theme_minimal()
cbind(fit_ts1$metrics, fit_ts2$metrics, fit_ts3$metrics)
data.frame(fit_ts1$metrics, fit_ts2$metrics, fit_ts3$metrics)
data.frame(fit_ts1 = fit_ts1$metrics,
fit_ts2 = fit_ts2$metrics,
fit_ts3 = fit_ts3fit_ts3$metrics)
data.frame(fit_ts1 = fit_ts1$metrics,
fit_ts2 = fit_ts2$metrics,
fit_ts3 = fit_ts3$metrics)
data.frame(fit_ts1 = as.numeric(fit_ts1$metrics),
fit_ts2 = as.numeric(fit_ts2$metrics),
fit_ts3 = as.numeric(fit_ts3$metrics))
names(fit_ts1$metrics)
colnames(fit_ts1$metrics)
print(data.frame(
metrics = colnames(fit_ts1$metrics),
fit_ts1 = as.numeric(fit_ts1$metrics),
fit_ts2 = as.numeric(fit_ts2$metrics),
fit_ts3 = as.numeric(fit_ts3$metrics)), digits = 3)
data.frame(
metrics = colnames(fit_ts1$metrics),
fit_ts1 = as.numeric(fit_ts1$metrics),
fit_ts2 = as.numeric(fit_ts2$metrics),
fit_ts3 = as.numeric(fit_ts3$metrics))
require(rmarkdown)
kableExtra::kable(data.frame(
metrics = colnames(fit_ts1$metrics),
fit_ts1 = as.numeric(fit_ts1$metrics),
fit_ts2 = as.numeric(fit_ts2$metrics),
fit_ts3 = as.numeric(fit_ts3$metrics)), digits = 3)
ro = rolling(fit_ts3, used.sample = 50, refit = 4, h = 4, orig.data = series)
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series[1:60,],
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3),
control = list(trace = 0)
)
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series[1:60,],
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3),
control = list(trace = 1)
)
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series[1:60,],
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3),
control = list(trace = 0) #
)
devtools::load_all(".")
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series[1:60,],
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3)
)
fit_ts3$coefficients
fit_ts3 = ConsRegArima(y ~ x1+x2+x3+x4, order = c(1, 1), data = series[1:60,],
LOWER = -1, UPPER = 1,
constraints = "x4 < x2",
ini.pars.coef = c(.9, .3, -.1, .3, -.3),
control = list(trace = 0) #  not show the trace of the optimizer
)
fit_ts3$coefficients
ro = rolling(fit_ts3, used.sample = 50, refit = 4, h = 4, orig.data = series)
ro
plot(ro) + theme_minimal()
ro$results
ro$results
ro$results
devtools::load_all(".")
rm(y)
ro = rolling(fit_ts3, used.sample = 50, refit = 4, h = 4, orig.data = series)
ro
rolling
y
require(ConsReg)
ro = rolling(object = fit_ts3, used.sample = 50,
refit = 4, h = 4, orig.data = series)
rolling
vignette('ConsReg')
R CMD check --as-cran
devtools::check_win_devel()
sessionInfo()
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
fit5 = ConsRegArima(y~x1+x2, order = c(1, 0), data = series,
optimizer = 'MCMCmetrop',
thin=2, mcmc=100000, burnin=500,
tune=rep(2, 4))
require(Rcpp)
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
r <- unclass(lsf.str(envir = asNamespace("statas"), all = T))
# filter weird names
r <- r[-grep("\\[", r)]
r <- r[-grep("<-", r)]
# create functions in the Global Env. with the same name
for(name in r) eval(parse(text=paste0(name, '<-stats:::', name)))
asNamespace("stats")
# filter weird names
r <- r[-grep("\\[", r)]
r <- unclass(lsf.str(envir = asNamespace("stats"), all = T))
# filter weird names
r <- r[-grep("\\[", r)]
r <- r[-grep("<-", r)]
r
# create functions in the Global Env. with the same name
for(name in r) eval(parse(text=paste0(name, '<-mypack:::', name)))
# create functions in the Global Env. with the same name
for(name in r) eval(parse(text=paste0(name, '<-stats:::', name)))
r
devtools::load_all(".")
devtools::load_all(".")
fit5 = ConsRegArima(y~x1+x2, order = c(1, 0), data = series,
optimizer = 'MCMCmetrop',
thin=2, mcmc=100000, burnin=500,
tune=rep(2, 4))
devtools::load_all(".")
fit5 = ConsRegArima(y~x1+x2, order = c(1, 0), data = series,
optimizer = 'MCMCmetrop',
thin=2, mcmc=100000, burnin=500,
tune=rep(2, 4))
devtools::load_all(".")
devtools::load_all(".")
fit5 = ConsRegArima(y~x1+x2, order = c(1, 0), data = series,
optimizer = 'MCMCmetrop',
thin=2, mcmc=100000, burnin=500,
tune=rep(2, 4))
devtools::load_all(".")
devtools::load_all(".")
devtools::load_all(".")
devtools::use_rcpp()
require(Rcpp)
devtools::load_all(".")
timesTwo(10)
source('~/Cositas/ConsReg/R/arma_fun2.R')
devtools::load_all(".")
devtools::load_all(".")
cppFunction('int signC(int x) {
if (x > 0) {
return 1;
} else if (x == 0) {
return 0;
} else {
return -1;
}
}')
signC(x = 10)
Rcpp::cppFunction("SEXP ARIMA_transPars(SEXP sin, SEXP sarma, SEXP strans)
{
int *arma = INTEGER(sarma), trans = asLogical(strans);
int mp = arma[0], mq = arma[1], msp = arma[2], msq = arma[3],
ns = arma[4], i, j, p = mp + ns * msp, q = mq + ns * msq, v;
double *in = REAL(sin), *params = REAL(sin), *phi, *theta;
SEXP res, sPhi, sTheta;
PROTECT(res = allocVector(VECSXP, 2));
SET_VECTOR_ELT(res, 0, sPhi = allocVector(REALSXP, p));
SET_VECTOR_ELT(res, 1, sTheta = allocVector(REALSXP, q));
phi = REAL(sPhi);
theta = REAL(sTheta);
if (trans) {
int n = mp + mq + msp + msq;
params = (double *) R_alloc(n, sizeof(double));
for (i = 0; i < n; i++) params[i] = in[i];
if (mp > 0) partrans(mp, in, params);
v = mp + mq;
if (msp > 0) partrans(msp, in + v, params + v);
}
if (ns > 0) {
/* expand out seasonal ARMA models */
for (i = 0; i < mp; i++) phi[i] = params[i];
for (i = 0; i < mq; i++) theta[i] = params[i + mp];
for (i = mp; i < p; i++) phi[i] = 0.0;
for (i = mq; i < q; i++) theta[i] = 0.0;
for (j = 0; j < msp; j++) {
phi[(j + 1) * ns - 1] += params[j + mp + mq];
for (i = 0; i < mp; i++)
phi[(j + 1) * ns + i] -= params[i] * params[j + mp + mq];
}
for (j = 0; j < msq; j++) {
theta[(j + 1) * ns - 1] += params[j + mp + mq + msp];
for (i = 0; i < mq; i++)
theta[(j + 1) * ns + i] += params[i + mp] *
params[j + mp + mq + msp];
}
} else {
for (i = 0; i < mp; i++) phi[i] = params[i];
for (i = 0; i < mq; i++) theta[i] = params[i + mp];
}
UNPROTECT(1);
return res;
}")
Rcpp::cppFunction("void cconv (int *l, int *m, double *x, int *n, double *s)
{
double *y, *z, *u;
int i;
for (i = 0; i < *m; i++)
{
y = x + (*n - l[i]);
z = x + l[i];
u = x;
s[i] = 0.0;
while (u < y)
s[i] += *u++ * *z++;
}
}")
cppFunction("
bool isOddCpp(int num = 10) {
bool result = (num % 2 == 1);
return result;
}")
Rcpp::sourceCpp("./src/prueba.cpp")
convolve_cpp(1, 4)
convolve_cpp(1:4, 4)
convolve_cpp(1:10, 4)
convolve_cpp(1:10, 2)
Rcpp::sourceCpp("./src/prueba.cpp")
add <- cfunction(c(a = "integer", b = "integer"), "
SEXP result = PROTECT(allocVector(REALSXP, 1));
REAL(result)[0] = asReal(a) + asReal(b);
UNPROTECT(1);
return result;
")
require(inline)
add <- cfunction(c(a = "integer", b = "integer"), "
SEXP result = PROTECT(allocVector(REALSXP, 1));
REAL(result)[0] = asReal(a) + asReal(b);
UNPROTECT(1);
return result;
")
dummy <- cfunction(body = '
SEXP dbls = PROTECT(allocVector(REALSXP, 4));
SEXP lgls = PROTECT(allocVector(LGLSXP, 4));
SEXP ints = PROTECT(allocVector(INTSXP, 4));
SEXP vec = PROTECT(allocVector(VECSXP, 3));
SET_VECTOR_ELT(vec, 0, dbls);
SET_VECTOR_ELT(vec, 1, lgls);
SET_VECTOR_ELT(vec, 2, ints);
UNPROTECT(4);
return vec;
')
dummy()
timesTwo <- function(x) {
.Call('C_ARIMA_CSS', PACKAGE = 'stats', x)
}
timesTwo <- function(x) {
.Call('C_ARIMA_CSS', PACKAGE = 'stats', ...)
}
timesTwo <- function(...) {
.Call('C_ARIMA_CSS', PACKAGE = 'stats', ...)
}
data('series')
formula = y~x1+x2
data = series
na.action = 'na.omit'
mf <- stats::model.frame(formula=formula, data=data, na.action = na.action)
x <- stats::model.matrix(attr(mf, "terms"), data=mf)
y <- stats::model.response(mf)
n = length(y)
arma <- as.integer(c(order, seasonal$order,
ifelse(is.na(seasonal$period), 1, seasonal$period),
0,0))
seasonal = list(order = c(0,0), period = 1)
arma <- as.integer(c(order, seasonal$order,
ifelse(is.na(seasonal$period), 1, seasonal$period),
0,0))
total_params = ncol(x) + sum(arma[1:4])
seasonal = list(order = c(0,0), period = 1)
seasonal
order
order = c(1,0)
n = length(y)
arma <- as.integer(c(order, seasonal$order,
ifelse(is.na(seasonal$period), 1, seasonal$period),
0,0))
total_params = ncol(x) + sum(arma[1:4])
ar = seq_len(order[1]) ; ma = seq_len(order[2])
sar = seq_len(seasonal$order[1]) ; sma = seq_len(seasonal$order[2])
mal = length(ma); arl = length(ar)
smal = length(sma); sarl = length(sar)
max.order = arma[1] + arma[5] * arma[3]
# Prepare bounds
prepareBounds <- function(upper, lower, total_params){
if(is.null(upper)) upper = rep(Inf, total_params)
if(length(upper) == 1) upper = rep(upper, total_params)
if(length(upper) != total_params)
upper = c(upper, rep(Inf,total_params-length(upper)))
if(is.null(lower))lower = rep(-Inf, total_params)
if(length(lower) == 1)lower = rep(lower, total_params)
if(length(lower) != total_params)
lower = c(lower, rep(-Inf,total_params-length(lower)))
lower = lower[1:total_params]
upper = upper[1:total_params]
return(list(upper = upper, lower = lower))
}
bounds = prepareBounds(upper = UPPER, lower = LOWER, total_params =  total_params)
UPPER = NULL
LOWER = NULL
bounds = prepareBounds(upper = UPPER, lower = LOWER, total_params =  total_params)
coef_reg <- stats::lm.fit(y = y, x = x)
coef_arma = stats::arima(stats::residuals(coef_reg), order = c(arma[1], 0, arma[2]),
seasonal = list(order = c(arma[3], 0, arma[4]), period = arma[5]),
include.mean = F)$coef
coef_reg = coef_reg$coefficients
i = 1:length(coef_reg)
if(length(coef_reg)>0){
coef_reg <- ifelse(data.table::between(coef_reg,
upper = bounds$upper[i],
lower = bounds$lower[i]), coef_reg,
runif(1, min = bounds$lower[i], max = bounds$upper[i]))
}
if(!is.null(ini.pars.coef)){
if(length(ini.pars.coef) != length(coef_reg)){
warning('Length of ini.pars.coef is not equal to parameters in the formula.
We use inital default parameter')
}else{
coef_reg = ini.pars.coef
}
}
ini_vars = c(coef_reg, coef_arma)
# optimization
names(ini_vars) = c(colnames(x),
if(arl > 0){paste0('ar', ar)}else{NULL},
if(mal > 0){paste0('ma', ma)}else{NULL},
if(sarl > 0){paste0('sar', sar)}else{NULL},
if(smal > 0){paste0('sma', sma)}else{NULL})
nms = names(ini_vars)
penalty  = 1000
constraints = NULL
coef = ini_vars
names(coef) = nms
coef_reg = coef[0:ncol(x)]
coef_arma = coef[(ncol(x)+1):length(coef)]
if(is.null(constraints)){
z = 0
}else{
text_split = strsplit(constraints, ',')[[1]]
TH <- data.table::setDT(as.list(coef))
z = sapply(text_split, function(cond){
with(TH, !eval(parse_expr(cond)))
})
z = any(z) * 1
}
trarma <- .Call(stats:::C_ARIMA_transPars, coef_arma, arma, FALSE)
n.cond = arma[1] + arma[5] * arma[3]
timesTwo(y - x %*% coef_reg,
arma, trarma[[1L]], trarma[[2L]],
n.cond, F)
timesTwo(y - x %*% coef_reg,
arma, trarma[[1L]], trarma[[2L]],
n.cond, F)
